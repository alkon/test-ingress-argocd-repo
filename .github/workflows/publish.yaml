name: Publish Python App & Helm Chart

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual trigger

jobs:
  # The 'lint' and 'test' jobs are commented out as per your provided YAML.
  # Uncomment and adjust 'needs' below if you reactivate them.
  # lint:
  #   uses: ./.github/workflows/reusable-python-job.yaml
  #   with:
  #     job-name: Lint
  #     python-version: ${{ matrix.python-version }}
  #     requirements-path: app/requirements.txt
  #     task-script: |
  #       pylint app/main.py --fail-under=7.0
  #     job-timeout-minutes: 15
  #   strategy:
  #     matrix:
  #       python-version: [ "3.12", "3.13" ]

  # test:
  #   uses: ./.github/workflows/reusable-python-job.yaml
  #   with:
  #     job-name: Test
  #     python-version: ${{ matrix.python-version }}
  #     requirements-path: app/requirements.txt
  #     task-script: |
  #       pytest app/tests # Adjust to the correct path for tests
  #     job-timeout-minutes: 15
  #   strategy:
  #     matrix:
  #       python-version: [ "3.12", "3.13" ]

  build-and-publish:
    runs-on: self-hosted
    # needs: lint # Uncomment if you reactivate the lint job
    # needs: [lint, test] # Uncomment if you reactivate both lint and test

    permissions:
      contents: read
      packages: write # Crucial for pushing Helm charts (packages) to GHCR

    outputs:
      chart_name: ${{ steps.chart.outputs.name }}
      chart_version: ${{ steps.chart.outputs.version }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

#      - name: Log in to GitHub Container Registry
#        uses: docker/login-action@v3
#        with:
#          registry: ghcr.io
#          username: ${{ github.actor }} # GitHub user triggered the workflow (e.g., 'alkon')
#          password: ${{ secrets.GITHUB_TOKEN }} # The auto-generated token with 'packages: write' permission

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GH_PAT }}

      - name: Extract Chart Metadata
        id: chart # IMPORTANT: This ID is used to reference outputs like steps.chart.outputs.name
        run: |
          # Find the *first* Chart.yaml in the ./helm/ directory structure.
          CHART_YAML_PATH=$(find ./helm -name Chart.yaml | head -n 1)
          
          if [ -z "$CHART_YAML_PATH" ]; then
            echo "Error: No Chart.yaml found in ./helm/ directory."
            exit 1
          fi
          
          # Extract version from Chart.yaml
          CHART_VERSION=$(grep '^version:' "$CHART_YAML_PATH" | cut -d ':' -f2 | xargs)
          echo "Chart version detected: $CHART_VERSION"
          echo "version=$CHART_VERSION" >> "$GITHUB_OUTPUT" # Output for current job steps and for job output
          echo "$CHART_VERSION" > chart-version.txt # For artifact upload
          
          # Extract name from Chart.yaml
          CHART_NAME=$(grep '^name:' "$CHART_YAML_PATH" | cut -d ':' -f2 | xargs)
          echo "Chart name detected: $CHART_NAME"
          echo "name=$CHART_NAME" >> "$GITHUB_OUTPUT" # Output for current job steps and for job output
          
          # Extract chart directory path (e.g., hello-chart from helm/hello-chart/Chart.yaml)
          CHART_DIRECTORY=$(dirname "$CHART_YAML_PATH" | xargs basename)
          echo "Chart directory name: $CHART_DIRECTORY"
          echo "chart_directory=$CHART_DIRECTORY" >> "$GITHUB_OUTPUT" # Output for current job steps

      - name: Upload Chart Version Artifact
        uses: actions/upload-artifact@v4
        with:
          name: chart-version
          path: chart-version.txt

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.18.0

      - name: Package & Push Helm Chart to GHCR OCI
        run: |
          CHART_DIR="./helm/${{ steps.chart.outputs.chart_directory }}" 
          CHART_PACKAGE=$(helm package "$CHART_DIR" --destination . | awk '{print $NF}')
          echo "Packaged chart: $CHART_PACKAGE"
          GHCR_OCI_TARGET="oci://ghcr.io/${{ github.repository_owner }}/${{ steps.chart.outputs.name }}"
          echo "Pushing Helm chart to GHCR OCI Repository: $GHCR_OCI_TARGET"
          helm push "$CHART_PACKAGE" "$GHCR_OCI_TARGET" --debug

  deploy:
    runs-on: self-hosted
    needs: build-and-publish # Crucial to get outputs from the 'build-and-publish' job

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Chart Version Artifact
        uses: actions/download-artifact@v4
        with:
          name: chart-version
          path: .

      - name: Set up Kubeconfig for K3D Cluster
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
          chmod 600 ~/.kube/config
          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV

      - name: Get Argo CD Admin Password and Sync
        id: get_argocd_password
        run: |
          ARGOCD_ADMIN_PASSWORD=$(kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath='{.data.password}' | base64 -d)
          echo "argocd_password=$ARGOCD_ADMIN_PASSWORD" >> "$GITHUB_OUTPUT"
          echo "Argo CD admin password retrieved successfully."
        timeout-minutes: 1

      - name: Start ArgoCD Service Port Forward
        uses: ./.github/actions/kubectl-port-forward
        with:
          service: argocd-server
          namespace: argocd
          local-port: 8443
          remote-port: 443
          wait-for-ready: true
          timeout: 60
        env:
          KUBECONFIG: ${{ env.KUBECONFIG }}

      - name: Apply Argo CD Application Manifest
        env:
          KUBECONFIG: ${{ env.KUBECONFIG }}
        run: |
          CHART_VERSION=$(cat chart-version.txt)
          echo "Detected CHART_VERSION: $CHART_VERSION"

          CHART_NAME_FROM_BUILD_JOB="${{ needs.build-and-publish.outputs.chart_name }}"
          echo "Chart name from build job: $CHART_NAME_FROM_BUILD_JOB"

          GHCR_HELM_OCI_FINAL_PATH="oci://ghcr.io/${{ github.repository_owner }}/${CHART_NAME_FROM_BUILD_JOB}"
          echo "GHCR Helm OCI Source URL for Argo CD: $GHCR_HELM_OCI_FINAL_PATH"

          # --- SED commands to replace all placeholders in argocd-apps/hello-chart-app.yaml.template ---
          # 1. Replace the Helm chart's OCI repoURL placeholder
          sed -i '' "s|\${HELM_CHART_OCI_REPO_URL}|$GHCR_HELM_OCI_FINAL_PATH|g" argocd-apps/hello-chart-app.yaml.template

          # 2. Define and replace Argo CD Application Name (e.g., hello-chart-app)
          ARGOCD_APP_NAME="${CHART_NAME_FROM_BUILD_JOB}-app"
          sed -i '' "s|\${ARGOCD_APP_NAME}|$ARGOCD_APP_NAME|g" argocd-apps/hello-chart-app.yaml.template

          # 3. Define and replace Destination Namespace (e.g., hello-chart)
          DESTINATION_NAMESPACE="${CHART_NAME_FROM_BUILD_JOB}"
          sed -i '' "s|\${DESTINATION_NAMESPACE}|$DESTINATION_NAMESPACE|g" argocd-apps/hello-chart-app.yaml.template

          # 4. Define and replace Helm Release Name (e.g., hello-chart-release)
          HELM_RELEASE_NAME="${CHART_NAME_FROM_BUILD_JOB}-release"
          sed -i '' "s|\${HELM_RELEASE_NAME}|$HELM_RELEASE_NAME|g" argocd-apps/hello-chart-app.yaml.template

          # 5. Replace chart name in source.chart (ensures it's dynamic from Chart.yaml)
          sed -i '' "s|\${CHART_NAME}|$CHART_NAME_FROM_BUILD_JOB|g" argocd-apps/hello-chart-app.yaml.template

          # --- COMMENTED OUT: Define and replace Docker Image Repository ---
          # This step is commented out as we are not pushing/referencing the Docker image from Docker Hub.
          # You might need to adjust your Helm chart's values.yaml or its Argo CD parameters
          # if 'image.repository' and 'image.tag' are still expected but no longer passed.
          # DOCKER_IMAGE_REPOSITORY="${{ secrets.DOCKERHUB_USERNAME }}/${CHART_NAME_FROM_BUILD_JOB}"
          # sed -i '' "s|\${DOCKER_IMAGE_REPOSITORY}|$DOCKER_IMAGE_REPOSITORY|g" argocd-apps/hello-chart-app.yaml.template
          # --- END COMMENTED OUT ---

          # 6. Replace CHART_VERSION (for targetRevision and image.tag)
          sed -i '' "s|\${CHART_VERSION}|$CHART_VERSION|g" argocd-apps/hello-chart-app.yaml.template

          mv argocd-apps/hello-chart-app.yaml.template argocd-apps/hello-chart-app.yaml

          echo "Applying Argo CD Application manifest..."
          kubectl apply -f argocd-apps/hello-chart-app.yaml
          echo "Argo CD Application manifest applied successfully."
          
          # --- CONDITIONAL SYNC LOGIC ---
          # Login to Argo CD CLI first
          argocd login localhost:8443 --username admin --password ${{ steps.get_argocd_password.outputs.argocd_password }} --insecure --grpc-web

          # Get current Argo CD application sync status
          SYNC_STATUS=$(argocd app get "$ARGOCD_APP_NAME" -o json | jq -r '.status.sync.status')
          echo "Current Argo CD application '$ARGOCD_APP_NAME' Sync Status: $SYNC_STATUS"

          # Force sync only if the status is Unknown or OutOfSync, and without --refresh
          if [[ "$SYNC_STATUS" == "Unknown" || "$SYNC_STATUS" == "OutOfSync" ]]; then
              echo "Application is '$SYNC_STATUS'. Forcing Argo CD application sync (without refresh)."
              argocd app sync "$ARGOCD_APP_NAME" --timeout 90 
              echo "Argo CD application sync command issued."
          else
              echo "Application is '$SYNC_STATUS'. No sync needed at this time (it should auto-sync)."
          fi
          # --- END RE-INTEGRATED ---

      - name: Check Application Health (with Diagnostics)
        uses: ./.github/actions/app-health-check
        with:
          app-name: "${{ needs.build-and-publish.outputs.chart_name }}-app"
          app-namespace: "${{ needs.build-and-publish.outputs.chart_name }}"
          wait-timeout: 90
          argocd-server-address: localhost:8443
          argocd-username: admin
          argocd-password: ${{ steps.get_argocd_password.outputs.argocd_password }}
        env:
          KUBECONFIG: ${{ env.KUBECONFIG }}